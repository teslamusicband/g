private void scanProcesses() {
    try {
        // alertActive = false; // УБРАТЬ эту строку
        Process proc = Runtime.getRuntime().exec("ps -eo pid,cmd --no-headers");
        
        boolean currentScanAlert = false; // Добавить локальную переменную
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                for (String pgDumpPath : PG_DUMP_PATHS) {
                    if (line.contains(pgDumpPath)) {
                        String pid = line.trim().split("\\s+")[0];
                        if (checkNetworkConnections(pid, line)) {
                            currentScanAlert = true;
                        }
                        break;
                    }
                }
            }
        }
        
        alertActive = currentScanAlert; // Установить значение после завершения сканирования
        
    } catch (Exception e) {
        log("ERROR", "Error scanning processes: " + e.getMessage());
    }
}










Да, это хорошее решение. Вот исправление для унификации интервалов:

```java
private static final long SCAN_INTERVAL = 1000; // Изменено с 5000 на 1000
private static final long METRICS_INTERVAL = 1000; // 1 second - оставляем как есть
```

Или еще лучше - использовать одну константу для обоих интервалов:

```java
private static final long MONITORING_INTERVAL = 1000; // 1 second

public void startMonitoring() {
    try {
        hostname = java.net.InetAddress.getLocalHost().getHostName();
    } catch (Exception e) {
        hostname = "unknown";
    }
    
    log("INFO", "Starting pg_dump monitoring on host: " + hostname);
    scheduler.scheduleAtFixedRate(this::scanProcesses, 0, MONITORING_INTERVAL, TimeUnit.MILLISECONDS);
    scheduler.scheduleAtFixedRate(this::sendMetrics, 0, MONITORING_INTERVAL, TimeUnit.MILLISECONDS);
}
```

Это решит проблему рассинхронизации между сканированием процессов и отправкой метрик. Теперь оба действия будут выполняться каждую секунду, и метрика будет отражать актуальное состояние `alertActive`.
