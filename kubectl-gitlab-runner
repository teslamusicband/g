Для установки kubectl в Alpine контейнере и настройки подключения к кластеру Kubernetes выполните следующие шаги:

## Установка kubectl в Alpine контейнере

```bash
# Обновляем пакеты
apk update

# Устанавливаем curl для загрузки kubectl
apk add --no-cache curl

# Загружаем последнюю версию kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

# Делаем файл исполняемым
chmod +x kubectl

# Перемещаем в системную директорию
mv kubectl /usr/local/bin/
```

Альтернативный способ через пакетный менеджер Alpine:

```bash
# Добавляем edge репозиторий
echo "https://dl-cdn.alpinelinux.org/alpine/edge/testing" >> /etc/apk/repositories

# Обновляем индекс пакетов
apk update

# Устанавливаем kubectl
apk add --no-cache kubectl
```

## Настройка подключения к кластеру

Поскольку ваш контейнер запущен внутри того же кластера Kubernetes, используйте Service Account для авторизации:

### 1. Использование встроенного Service Account

```bash
# Kubernetes автоматически монтирует токен Service Account
export KUBECONFIG=/var/run/secrets/kubernetes.io/serviceaccount

# Или настройте kubectl для использования in-cluster конфигурации
kubectl config set-cluster kubernetes --server=https://kubernetes.default.svc --certificate-authority=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
kubectl config set-credentials serviceaccount --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
kubectl config set-context kubernetes --cluster=kubernetes --user=serviceaccount
kubectl config use-context kubernetes
```

### 2. Создание kubeconfig файла

```bash
# Создаем директорию для конфигурации
mkdir -p ~/.kube

# Создаем kubeconfig
cat > ~/.kube/config << EOF
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    server: https://kubernetes.default.svc
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: serviceaccount
  name: kubernetes
current-context: kubernetes
users:
- name: serviceaccount
  user:
    tokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
EOF
```

## Настройка прав доступа

Для работы с кластером может потребоваться настройка RBAC. Создайте соответствующие права для Service Account:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: gitlab-runner-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "create", "update", "delete"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "create", "update", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: gitlab-runner-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gitlab-runner-role
subjects:
- kind: ServiceAccount
  name: default  # или имя вашего Service Account
  namespace: default  # namespace где запущен gitlab-runner
```

## Проверка подключения

```bash
# Проверяем подключение к кластеру
kubectl cluster-info

# Проверяем доступные ресурсы
kubectl get nodes
kubectl get pods
```

## Для GitLab CI/CD

В вашем `.gitlab-ci.yml` можете использовать:

```yaml
deploy:
  image: alpine:3.20.6
  before_script:
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl && mv kubectl /usr/local/bin/
    - mkdir -p ~/.kube
    - cat > ~/.kube/config << EOF
        # конфигурация выше
      EOF
  script:
    - kubectl get pods
    - kubectl apply -f deployment.yaml
```

Эта конфигурация позволит вашему контейнеру взаимодействовать с кластером Kubernetes, используя встроенные механизмы авторизации через Service Account.
